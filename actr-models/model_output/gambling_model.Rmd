---
title: "gambling_model"
author: "Cher"
date: "4/15/2021"
output:
  html_document:
    code_folding: hide
    theme: yeti
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
  word_document:
    toc: yes
    toc_depth: '3'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning = FALSE, error = FALSE, message = FALSE)
library(plyr)
library(ggthemes)
library(ggplot2)
library(ggsci)
library(tidyverse)
library(xtable)
library(kableExtra)
library(pracma)  # imports Mode function
library(rstatix)
library(tidyverse) # handy utility functions
library(dplyr)
library(ggpubr)
library(tidyverse)
library(ggpubr)
library(rstatix)
library(lme4)
library(sjPlot)
library(ggeffects)
library(Metrics)
rm(list = ls())
```

# Load Model Data

Description of two models: 

Two simple models are implemented in ACT-R, performing the gambling task depending on two distinctive mechanisms.

### Model1: Declarative Model (version 2.0)

The model randomly evaluates an action GUESS-MORE or GUESS-LESS, then retrieving memories about prior feedback. If "WIN" memory is retrieved, the model chooses the evaluated action. If "LOSE"/"Neutral" memory is retrieved, the model chooses the alternative action. 


### Model2: RL Models. 

The model makes decision relying on procedural memory, pressing "MORE"/"LESS" key. GUESS-MORE and GUESS-LESS productions are competing. In the end, a feedback is given, the model receives either +1/-1/0 reward to all previous productions, and the utility of all previous fired productions will be affected. 

```{r}
model1.raw <- read.csv("./MODEL120210423_102311_fnca_log.csv") #%>% rename(Trial=X)
model2.raw <- read.csv("./MODEL220210423_102311_fnca_log.csv") #%>% rename(Trial=X)

#model1 <- read.csv("MODEL120210420.csv")
#model2 <- read.csv("MODEL220210420.csv")

model1.raw <- model1.raw %>% 
  mutate(CurrentResponse = case_when(Response=="j" ~ 3,
                                     Response=="f" ~ 2),
         RT = as.numeric(RT),
         Epoch = as.numeric(Epoch)) 

model2.raw <- model2.raw %>%
  mutate(CurrentResponse = case_when(Response=="j" ~ 3,
                                     Response=="f" ~ 2),
         RT = as.numeric(RT),
         Epoch = as.numeric(Epoch)) 

# only 
model1 <- model1.raw %>% filter(ans==.1 & bll==.1 & lf==.1)
model2 <- model2.raw %>% filter(alpha==.1 & egs==.1 & r==.1)
```

# Compute win-stay probabilities

```{r}
future_moves <- function(responses) {
  c(responses[2:length(responses)], NA)
}
past_moves <- function(responses) {
  c(NA, responses[1:length(responses)-1])
}

count_responses <- function(model.dat) {
  model.dat <- model.dat %>%
   mutate(FutureResponse = future_moves(CurrentResponse),
         PastResponse = past_moves(CurrentResponse),
         PreviousFeedback = past_moves(TrialType),
         ResponseSwitch = if_else(CurrentResponse == FutureResponse, 0, 1))
  return(model.dat)
}

# NA for all first trial in each block
clean_previous_future <- function(model.dat) {
  model.dat <- model.dat %>%
    mutate(PastResponse=ifelse(BlockTrial==0, NA, PastResponse),
           PreviousFeedback=ifelse(BlockTrial==0, NA, PreviousFeedback),
           FutureResponse=ifelse(BlockTrial==7, NA, FutureResponse),
           ResponseSwitch=ifelse(BlockTrial==7, NA, ResponseSwitch),
           )
  return(model.dat)
}

#model1.count <- clean_previous_future(count_responses(model1))
```


```{r}
aggregate.CurrentTrial <- function(model.dat) {
  model.aggregate <- model.dat %>%
  filter(!is.na(ResponseSwitch) & !is.na(CurrentResponse)) %>%
  group_by(Epoch, BlockType, TrialType) %>%
  dplyr::summarise(PSwitch = mean(ResponseSwitch), RT = mean(RT))
  return (model.aggregate)
}

aggregate.PreviousTrial <- function(model.dat) {
  model.aggregate <- model.dat %>%
  filter(!is.na(ResponseSwitch) & !is.na(PreviousFeedback) & !is.na(CurrentResponse)) %>%
  group_by(Epoch, BlockType, PreviousFeedback) %>%
  dplyr::summarise(PSwitch = mean(ResponseSwitch), RT = mean(RT))
  return (model.aggregate)
}

#model1.aggregate <- aggregate.CurrentTrial(model1.count)
#model1.aggregate
```

```{r}
PSwitch.aggplot <- function(aggregate.dat, subjID) {
  # res <- ggplot(aggregate.dat,
  #      aes(x = TrialType, y = PSwitch, col = TrialType)) +
  # facet_grid( ~ BlockType) +
  # geom_point(alpha = 0.3, size=3) +
  # scale_color_brewer(palette = "Set2") +
  # stat_summary(fun.data = "mean_cl_boot", col="black") +
  # ylim(0,1) +
  # theme_pander()
  
  if(!is.na(subjID)) {
    res <- ggplot(aggregate.dat %>% filter(HCPID==subjID), 
                  aes(x = TrialType, y = PSwitch)) +
    facet_grid( ~ BlockType) +
    geom_line(aes(group = BlockType), alpha=.5) + 
    geom_point(alpha=.5, size=3, aes(col=TrialType)) +
    ylim(0,1) +
    theme_pander()
   
  } else {
    res <- ggplot(aggregate.dat, aes(x = TrialType, y = PSwitch, col = Epoch)) +
    facet_grid( ~ BlockType) +
    geom_line(aes(group = Epoch), alpha=.5) + 
    geom_point(alpha=.5, size=3) +
    ylim(0,1) +
    guides(col=FALSE) +
    stat_summary(fun.data = "mean_cl_boot", col="black") +
    theme_pander()
  }
  
  return(res)
}
RT.aggplot <- function(aggregate.dat, subjID) {
  # res <- ggplot(aggregate.dat,
  #      aes(x = TrialType, y = RT, col = TrialType)) +
  # facet_grid( ~ BlockType) +
  # geom_point(position = position_jitter(width = 0.1, height = 0.05),
  #            alpha = 0.3, size=3) +
  # scale_color_brewer(palette = "Set2") +
  # stat_summary(fun.data = "mean_cl_boot", col="black") +
  # ylim(0,2) +
  # theme_pander()
  if(!is.na(subjID)) {
    
    # plot  human data
    res <- ggplot(aggregate.dat %>% filter(HCPID==subjID), 
                  aes(x = TrialType, y = RT)) +
    facet_grid( ~ BlockType) +
    geom_line(aes(group = BlockType), alpha=.5) + 
    geom_point(alpha=.5, size=3, aes(col=TrialType)) +
    ylim(0,1) +
    theme_pander()
  
    # plot model data
  } else {
    res <- ggplot(aggregate.dat, aes(x = TrialType, y = RT, col = Epoch)) +
    facet_grid( ~ BlockType) +
    geom_line(aes(group = Epoch), alpha=.5) + 
    geom_point(alpha=.5, size=3) +
    ylim(0,1500) +
    guides(col=FALSE) +
    stat_summary(fun.data = "mean_cl_boot", col="black") +
    theme_pander()
  }
  return(res)
}

```


Let's look at the PSwitch and RT as a function of Current TrialType

```{r}
model1.count <- clean_previous_future(count_responses(model1))
model2.count <- clean_previous_future(count_responses(model2))


model1.aggregate <- aggregate.CurrentTrial(model1.count)
model2.aggregate <- aggregate.CurrentTrial(model2.count)

```


```{r}
PSwitch.aggplot(model1.aggregate, NA) + ggtitle("MODEL1")
PSwitch.aggplot(model2.aggregate, NA) + ggtitle("MODEL2")


RT.aggplot(model1.aggregate, NA) + ggtitle("MODEL1")
RT.aggplot(model2.aggregate, NA) + ggtitle("MODEL1")
```

### Summary of Pswitch vs. CurrentTrial

Model1:

Model2:


### Summary of RT vs. CurrentTrial

Model1:

Model2:


```{r}
model1.pf_aggregate <- aggregate.PreviousTrial(model1.count)
model2.pf_aggregate <- aggregate.PreviousTrial(model2.count)

```

```{r}
PSwitch.pfaggplot <- function(aggregate.dat, subjID) {
  # res <- ggplot(aggregate.dat,
  #      aes(x = PreviousFeedback, y = PSwitch, col = PreviousFeedback, 
  #          group = PreviousFeedback)) +
  # facet_grid( ~ BlockType, labeller = label_both) +
  # geom_point(alpha = 0.3, size=3) +
  # scale_color_brewer(palette = "Set2") +
  # stat_summary(fun.data = "mean_cl_boot", col="black") +
  # ylim(0,1) +
  # theme_pander()
  
  # plot subject
  if(!is.na(subjID)) {
    res <- ggplot(aggregate.dat %>% filter(HCPID==subjID), 
                  aes(x = PreviousFeedback, y = PSwitch)) +
    facet_grid( ~ BlockType) +
    geom_line(aes(group = BlockType), alpha=.5) + 
    geom_point(alpha=.5, size=3, aes(col=PreviousFeedback)) +
    ylim(0,1) +
    theme_pander()
   
    # plot model
  } else {
    res <- aggregate.dat %>% 
    ggplot(aes(x = PreviousFeedback, y = PSwitch, col  = Epoch)) +
    facet_grid( ~ BlockType, labeller = label_both) +
    geom_line(aes(group = Epoch), alpha=.5) + 
    geom_point(alpha=.5, size=3) +
    ylim(0,1) +
    guides(col=FALSE) +
    stat_summary(fun.data = "mean_cl_boot", col="black") +
    theme_pander()
  }
  
  return(res)
}

RT.pfaggplot <- function(aggregate.dat, subjID) {
  # res <- ggplot(aggregate.dat,
  #      aes(x = PreviousFeedback, y = RT, col = PreviousFeedback)) +
  # facet_grid( ~ BlockType, labeller = label_both) +
  # geom_point(alpha = 0.3, size=3) +
  # scale_color_brewer(palette = "Set2") +
  # ylim(0,1) +
  # stat_summary(fun.data = "mean_cl_boot", col="black") +
  # theme_pander()
  
  # plot subject
  if(!is.na(subjID)) {
    res <- ggplot(aggregate.dat %>% filter(HCPID==subjID), 
                  aes(x = PreviousFeedback, y = RT)) +
    facet_grid( ~ BlockType) +
    geom_line(aes(group = BlockType), alpha=.5) + 
    geom_point(alpha=.5, size=3, aes(col=PreviousFeedback)) +
    ylim(0,1) +
    theme_pander()
   
    # plot model
  } else {
    res <- aggregate.dat %>% 
    ggplot(aes(x = PreviousFeedback, y = RT, col  = Epoch)) +
    facet_grid( ~ BlockType, labeller = label_both) +
    geom_line(aes(group = Epoch), alpha=.5) + 
    geom_point(alpha=.5, size=3) +
    ylim(0,1500) +
    guides(col=FALSE) +
    stat_summary(fun.data = "mean_cl_boot", col="black") +
    theme_pander()
  }
  return(res)
}
```


Let's visualize it 
```{r}
PSwitch.pfaggplot(model1.pf_aggregate, NA) + ggtitle("MODEL1")
PSwitch.pfaggplot(model2.pf_aggregate, NA) + ggtitle("MODEL2")
```

```{r eval=F}
aov(PSwitch ~ BlockType * PreviousFeedback, model2.pf_aggregate  %>% filter(PreviousFeedback!="Neutral"))  %>%
  anova_summary() %>%
  xtable() %>%
  kable(digits=4) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

aov(RT ~ BlockType * PreviousFeedback, model2.pf_aggregate  %>% filter(PreviousFeedback!="Neutral"))  %>%
  anova_summary() %>%
  xtable() %>%
  kable(digits=4) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

```

### Summary of Pswicth vs. PreviousTrial

Model1:

Model2:


### Summary of RT vs. PreviousTrial

Model1:

Model2:







```{r eval=F}
blockId <- sort(rep(1:4, 8))

gambling <- gambling %>% 
  group_by(HCPID, RunNumber) %>%
  mutate(BlockId = blockId, 
         Response = if_else(is.na(QuestionMark.RESP), 0, QuestionMark.RESP))

bg <- gambling %>%
  group_by(BlockId, HCPID, RunNumber) %>%
  summarise(BlockType = paste("Mostly", Mode(TrialType)))

gambling <- inner_join(gambling, bg)

past_moves <- function(responses) {
  c(NA, responses[1:length(responses)-1])
}

gambling <- gambling %>%
  group_by(RunNumber, BlockId) %>%
  mutate(CurrentResponse = Response,
         FutureResponse = future_moves(Response),
         PastResponse = past_moves(Response),
         PreviousFeedback = past_moves(TrialType),
         RT = QuestionMark.RT/1200) %>%
  filter(FutureResponse != 0) %>%
  #filter(CurrentResponse != 0) %>%
  mutate(ResponseSwitch = if_else(CurrentResponse == FutureResponse, 0, 1))   %>%
  select(HCPID, RunNumber, BlockId, RT, Response, PastResponse,
         CurrentResponse, FutureResponse, ResponseSwitch, BlockType, TrialType,
         PreviousFeedback, FeedbackImage)

gambling$PreviousFeedback <- as_factor(gambling$PreviousFeedback)
gambling$PreviousFeedback <- revalue(gambling$PreviousFeedback,
                                         c("1"="Reward", 
                                           "2"="Punishment", 
                                           "3"="Neutral"))
```

```{r eval=F}
subj1.aggregate <- aggregate.CurrentTrial(gambling)
subj1.pf_aggregate <- aggregate.PreviousTrial(gambling)

PSwitch.aggplot(subj1.aggregate) + ggtitle("SUBJ - 100307")
RT.aggplot(subj1.aggregate) + ggtitle("SUBJ - 100307")

PSwitch.pfaggplot(subj1.pf_aggregate) + ggtitle("SUBJ - 100307")
RT.pfaggplot(subj1.pf_aggregate) + ggtitle("SUBJ - 100307")


```

```{r eval=F}
gambling <- read_tsv("../../gambling_data.txt")
gambling.trials <- gambling %>% 
  #filter(RunNumber==1) %>%
  select(HCPID, Trial, RunNumber, TrialType, RunTrialNumber, Block, 
         QuestionMark.RESP, QuestionMark.ACC, QuestionMark.RT,
         R1MostlyReward1, R1MostlyReward2, R1MostlyPunishment1, R1MostlyPunishment3, QuestionMark.OnsetDelay, 
         ConsecSameResp, ConsecLargerGuesses, ConsecSmallerGuesses, ConsecRTLess200) %>% 
  rename(CurrentResponse=QuestionMark.RESP, RT=QuestionMark.RT)  %>%
  mutate(FutureResponse = future_moves(CurrentResponse),
         PastResponse = past_moves(CurrentResponse), 
         ResponseSwitch = if_else(CurrentResponse == FutureResponse, 0, 1),
         PreviousFeedback = past_moves(as.character(TrialType)),
         BlockType = case_when(
           !is.na(R1MostlyReward1) ~ "MostlyReward", 
           !is.na(R1MostlyReward2) ~ "MostlyReward", 
           !is.na(R1MostlyPunishment1) ~ "MostlyPunishment", 
           !is.na(R1MostlyPunishment3) ~ "MostlyPunishment"
         )) %>%
  select(-R1MostlyReward1, -R1MostlyReward2, -R1MostlyPunishment1, -R1MostlyPunishment3) %>%
  filter(!is.na(TrialType))

#write.csv(gambling.trials, "../../gambling_clean_data.csv")
```

```{r eval=F}
gambling.aggregate <- gambling.trials.session1 %>% 
  filter(!is.na(ResponseSwitch) & !is.na(RT)) %>%
  group_by(HCPID, TrialType, BlockType, PreviousFeedback) %>%
  summarise(PSwitch = mean(ResponseSwitch),RT = mean(RT))

ggplot(gambling.aggregate,
       aes(x = TrialType, y = PSwitch, col = TrialType)) +
  facet_grid( ~ BlockType, labeller = label_both) +
  geom_point(position = position_jitter(width = 0.1, height = 0.05),
             alpha = 0.1) +
  scale_color_brewer(palette = "Set2") +
  stat_summary(fun.data = "mean_cl_boot", col="black") +
  theme_pander()

gambling.trials <- gambling.trials.session1 %>% select(HCPID, Trial, RunTrialNumber, TrialType, BlockType)

gambling.trials.session1 %>%
  gghistogram("RT", add = "median")
  
```


# Load Subject Data

```{r eval=FALSE}
gambling.clean <- read_csv("../../bin/gambling_clean_data.csv") %>% 
  select(-BlockType) %>% rename(BlockType=BlockTypeCoded)


gambling.cfagg <- gambling.clean %>%
  na.omit() %>%
  group_by(HCPID, BlockType, TrialType) %>%
  summarise(PSwitch = mean(ResponseSwitch), RT = mean(RT))

gambling.pfagg <- gambling.clean %>%
  na.omit() %>%
  group_by(HCPID, BlockType, PreviousFeedback) %>%
  summarise(PSwitch = mean(ResponseSwitch), RT = mean(RT))

# long format
gambling.cfagg <- left_join(gambling.cfagg %>% select(-RT) %>%
  spread(key = TrialType, value = PSwitch, sep = "."),
  gambling.cfagg %>% select(-PSwitch) %>%
  spread(key = TrialType, value = RT, sep = "."),
  by = c("HCPID", "BlockType"), suffix=c(".PSwitch",".RT"))

gambling.pfagg <- left_join(gambling.pfagg %>% select(-RT) %>%
  spread(key = PreviousFeedback, value = PSwitch, sep = "."),
  gambling.pfagg %>% select(-PSwitch) %>%
  spread(key = PreviousFeedback, value = RT, sep = "."),
  by = c("HCPID", "BlockType"), suffix=c(".PSwitch",".RT"))

#write_csv(gambling.cfagg, "../../bin/gambling_cfagg.csv")
#write_csv(gambling.pfagg, "../../bin/gambling_pfagg.csv")
```

Load clean data and select one subj data

Note: here, ResponseSwitch is 1 if: CurrentResponse != FutureResponse; is 0 if CurrentResponse==FutureResponse

```{r}
gambling.clean <- read_csv("../../bin/gambling_clean_data.csv") %>% mutate(BlockType=BlockTypeCoded)
subjID = "102311_fnca"

#  Pswitch as a function of current trial type and block type
gambling.cfaggregate = gambling.clean %>%
  filter(!is.na(ResponseSwitch) & !is.na(CurrentResponse)) %>% 
  group_by(HCPID, BlockType, TrialType) %>%
  dplyr::summarise(PSwitch = mean(ResponseSwitch, rm.na=T), RT = mean(RT, rm.na=T))

#  Pswitch as a function of previous trial type and block type
gambling.pfaggregate = gambling.clean %>%
  filter(!is.na(ResponseSwitch) & !is.na(PreviousFeedback)) %>% 
  group_by(HCPID, BlockType, PreviousFeedback) %>%
  dplyr::summarise(PSwitch = mean(ResponseSwitch, rm.na=T), RT = mean(RT, rm.na=T))

```


```{r eval=FALSE}
# test whether prop is calculate correctly
gambling.cfaggregate %>% filter(HCPID==subjID)
gambling.clean %>% filter(HCPID==subjID) %>%
  filter(!is.na(ResponseSwitch)) %>%
  group_by(BlockType, TrialType , ResponseSwitch) %>%
  dplyr::summarise(n=n()) %>%
  mutate(freq = n / sum(n)) %>%
  xtable() %>% kable(digits=4) %>% kable_styling(bootstrap_options = c("striped", "hover"))

#>> yes correct
```


Visualize subject Pswitch pattern as a function of previous feedback

```{r}
PSwitch.aggplot(gambling.cfaggregate, subjID) + ggtitle(paste("SUB", subjID, sep = "-"))
PSwitch.pfaggplot(gambling.pfaggregate, subjID) + ggtitle(paste("SUB", subjID, sep = "-"))

```


# Calculate RMSE and Find Best Fit Parameter

Distribution of model1 parameters :ans, :bll, :lf

Note: This is not grid-search parameter fitting. The parameter space was chosen by optimization function
by adding null_penalty (count of null responses)

```{r}
dim(model1.raw)

model1.full.count <- clean_previous_future(count_responses(model1.raw))

model1.full.agg <- model1.full.count %>% 
  filter(!is.na(ResponseSwitch) & !is.na(CurrentResponse)) %>%
  group_by(ans, bll, lf, BlockType, TrialType) %>%
  dplyr::summarise(PSwitch = mean(ResponseSwitch), RT = mean(RT))

model1.full.agg %>% gghistogram(x="ans", binwidth = .05)
model1.full.agg %>% gghistogram(x="bll", binwidth = .05)
model1.full.agg %>% gghistogram(x="lf", binwidth = .05)

```


Distribution model2 parameter :egs, :alpha, and :r


```{r}
dim(model2.raw)

model2.full.count <- clean_previous_future(count_responses(model2.raw))

model2.full.agg <- model2.full.count %>% 
  filter(!is.na(ResponseSwitch) & !is.na(CurrentResponse)) %>%
  group_by(egs, alpha, r, BlockType, TrialType) %>%
  dplyr::summarise(PSwitch = mean(ResponseSwitch), RT = mean(RT))

model2.full.agg %>% gghistogram(x="egs", binwidth = .05)
model2.full.agg %>% gghistogram(x="alpha", binwidth = .05)
model2.full.agg %>% gghistogram(x="r", binwidth = .05)

```


Next, we calalculate RMSE for each parameter combination, find the best parameter with min RMSE


```{r}
find_best_parameter <- function(model, model.agg, sub.agg) {
  if (model=="model1") {
    m1.param <- unique(model.agg[,c('ans','bll','lf')])
    #m1.param=m1.param[1:10,]
    m1.param$RMSE = NA
    m1.param$RMSE = as.numeric(m1.param$RMSE)
    
    for (i in 1:nrow(m1.param)) {
      m1.agg <- model.agg %>% 
        filter(ans==m1.param[[i,'ans']] & bll==m1.param[[i,'bll']] & lf==m1.param[[i,'lf']])
        rmse_value <- rmse(m1.agg$PSwitch, sub.agg$PSwitch)
      m1.param[[i, 'RMSE']] <- rmse_value
    }
    return (m1.param)
  } else {
    m2.param <- unique(model.agg[,c('egs','alpha','r')])
    #m2.param=m2.param[1:10,]
    m2.param$RMSE = NA
    m2.param$RMSE = as.numeric(m2.param$RMSE)
    
    for (i in 1:nrow(m2.param)) {
      m2.agg <- model.agg %>% 
        filter(egs==m2.param[[i,'egs']] & alpha==m2.param[[i,'alpha']] & r==m2.param[[i,'r']])
        rmse_value <- rmse(m2.agg$PSwitch, sub.agg$PSwitch)
      m2.param[[i, 'RMSE']] <- rmse_value
    }
    return (m2.param)
  }
  
}

m1.bestp <- find_best_parameter("model1", model1.full.agg, gambling.cfaggregate)
m2.bestp <- find_best_parameter("model2", model2.full.agg, gambling.cfaggregate)
m1.bestp$model = "model1"
m2.bestp$model = "model2"

```



```{r}

m1.bestp <- m1.bestp[order(m1.bestp$RMSE),]
m2.bestp <- m2.bestp[order(m2.bestp$RMSE),]

m1.bestp %>% head() %>% xtable() %>% kable(digits=4) %>% kable_styling(bootstrap_options = c("striped", "hover"))
m2.bestp %>% head() %>% xtable() %>% kable(digits=4) %>% kable_styling(bootstrap_options = c("striped", "hover"))

m1.bestp[[1,'ans']]
```



By looking at min RMSE:

Best parameter chosen for model1 :ans=`r m1.bestp[[1,'ans']]` :bll=`r m1.bestp[[1,'bll']]`, :lf=`r m1.bestp[[1,'lf']]`

Best parameter chosen for model2 is :egs=`r m2.bestp[[1,'egs']]` ; alpha=`r m2.bestp[[1,'alpha']]`, :r=`r m2.bestp[[1,'r']]`


# Calculate Log-Likelihood








